from math import fsum
from tetra.ksample import OptimizeGs, MakeEks, MakeXks
from tetra.submesh import MakeSubmesh, MakeTetra
from tetra.fermi import FindFermi
from tetra.weights import Weights

def SumFn(n, Efn, Xfn, R, num_electrons, tolerance=None):
    '''Calculate the expectation value of Xfn over the Brillouin zone
    using the tetrahedron method. Returns the expectation value, as well as
    the submesh density n used to achieve the specified tolerance and the
    integration weights used (for use in additional summations by SumMesh).

    n = Brillouin zone submesh density (the total number of k-points sampled
    is (n+1)**3).

    Efn = a function E(k) which returns a list of the band energies at the
    Brillouin zone point k, with the returned list sorted in ascending order;
    k is expressed in the reciprocal lattice basis.

    Xfn = a function X(k) which returns a list of the values of the matrix
    elements of the operator X at k; the returned values are ordered in the
    same way as the band energies and k is expressed in the reciprocal
    lattice basis.

    R = a numpy matrix with rows given by the reciprocal lattice vectors.

    tolerance = summation error tolerance. If tolerance != None, the value
    of n is repeatedly doubled (starting from the given value) until the
    difference between iterations is less than tolerance.
    '''
    # Calculate the expectation value for a particular n.
    def doSum(this_n):
        G_order, G_neg, submesh, Eks, ws = _sum_setup(this_n, Efn, R, num_electrons)
        # Sample X.
        Xks = MakeXks(Xfn, submesh, G_order, G_neg)
        # Calculate sum.
        result = _SumByWeights(ws, Xks)
        return result, ws
    # Refine n until tolerance is met.
    return _sum_until_tol(doSum, n, tolerance)

def _sum_setup(n, Efn, R, num_electrons):
    '''Setup for summation common to SumFn and SumEnergy.
    '''
    # Get optimal reciprocal lattice orientation.
    G_order, G_neg = OptimizeGs(R)
    # Generate submesh and tetrahedra.
    submesh = MakeSubmesh(n)
    tetras = MakeTetra(n)
    # Sample E.
    Eks = MakeEks(Efn, submesh, G_order, G_neg)
    # Get Fermi energy by n(E_F) = num_electrons.
    E_Fermi = FindFermi(num_electrons, tetras, Eks)
    # Get integration weights.
    ws = Weights(E_Fermi, tetras, Eks)
    return G_order, G_neg, submesh, Eks, ws

def _sum_until_tol(doSum, n, tolerance):
    last_result = None
    result, ws = doSum(n)
    if tolerance == None:
        return result, n, ws
    try_n = 2*n
    while not _sum_finished(result, last_result, tolerance):
        last_result = result
        result, ws = doSum(try_n)
        try_n = 2*try_n
    return result, try_n/2, ws

def _sum_finished(result, last_result, tolerance):
    if last_result == None:
        return False
    elif abs(result - last_result) > tolerance:
        return False
    else:
        return True

def _SumByWeights(weights, Xks):
    '''Calculate the expectation value <X> over the Brillouin zone
    using the tetrahedron method, given precalculated (k,n) integration
    weights and sampled values of X_n(k).

    weights = a list of integration weights w[n][j].

    Xks = a list of matrix elements X[j][n], with band indices ordered in the
    same way as the eigenstate energies. Xks can be generated by
    ksample.MakeXks.
    '''
    num_bands = len(weights)
    num_ks = len(weights[0])
    mult_vals = []
    # Accumulate list of values and then sum to take advantage of
    # floating-point error correction in fsum.
    for j in range(num_ks):
        for n in range(num_bands):
            mult_vals.append(Xks[j][n]*weights[n][j])
    return fsum(mult_vals)

def SumEnergy(n, Efn, R, num_electrons, tolerance=None):
    '''Calculate the expectation value of the energy over the Brillouin zone
    using the tetrahedron method. Returns the expectation value, as well as
    the submesh density n used to achieve the specified tolerance and the
    integration weights used (for use in additional summations by SumMesh).

    n = Brillouin zone submesh density (the total number of k-points sampled
    is (n+1)**3).

    Efn = a function E(k) which returns a list of the band energies at the
    Brillouin zone point k, with the returned list sorted in ascending order;
    k is expressed in the reciprocal lattice basis.

    R = a numpy matrix with rows given by the reciprocal lattice vectors.

    tolerance = summation error tolerance. If tolerance != None, the value
    of n is repeatedly doubled (starting from the given value) until the
    difference between iterations is less than tolerance.
    '''
    # Calculate the expectation value for a particular n.
    def doSum(this_n):
        G_order, G_neg, submesh, Eks, ws = _sum_setup(this_n, Efn, R, num_electrons)
        # Calculate sum.
        result = _SumByWeights(ws, Eks)
        return result, ws
    # Refine n until tolerance is met.
    return _sum_until_tol(doSum, n, tolerance)

def SumMesh(weights, n, Xfn, R):
    '''Calculate the expectation value <X> over the Brillouin zone
    using the tetrahedron method, given precalculated (k,n) integration
    weights.

    weights = a list of integration weights w_{nj}.

    n = Brillouin zone submesh density (the total number of k-points sampled
    is (n+1)**3).

    Xfn = a function X(k) which returns a list of the values of the matrix
    elements of the operator X at k; the returned values are ordered in the
    same way as the band energies and k is expressed in the reciprocal
    lattice basis.

    R = a numpy matrix with rows given by the reciprocal lattice vectors.

    The expectation value is given by:
        <X> = \sum_{j, n} X_n(k_j) w_{nj}
    (BJA94 Eq. 4).
    '''
    # Get optimal reciprocal lattice orientation.
    G_order, G_neg = OptimizeGs(R)
    # Generate submesh.
    submesh = MakeSubmesh(n)
    # Sample X.
    Xks = MakeXks(Xfn, submesh, G_order, G_neg)
    # Calculate sum.
    result = _SumByWeights(ws, Xks)
    return result
